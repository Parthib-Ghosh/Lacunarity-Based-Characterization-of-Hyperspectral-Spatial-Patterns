# -*- coding: utf-8 -*-
"""PaviaU.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-LaieBEr9UkCEvIjHhkvjBJxlUg77E8q
"""

import numpy as np
from scipy.io import loadmat
import matplotlib.pyplot as plt

# Load PaviaU dataset from MATLAB file
PaviaU_data = loadmat('/content/PaviaU.mat')  # Update the path
PaviaU = PaviaU_data['paviaU']  # Adjust based on the structure of your .mat file

# Reshape the data to (num_pixels, num_bands) for easier computation
reshaped_data = np.reshape(PaviaU, (PaviaU.shape[0] * PaviaU.shape[1], PaviaU.shape[2]))

# Calculate the standard deviation for each band
band_std_dev = np.std(reshaped_data, axis=0)

# Find the band with the maximum standard deviation
max_info_band = np.argmax(band_std_dev)

# Plot the standard deviation values for each band
plt.plot(band_std_dev)
plt.xlabel('Band Index')
plt.ylabel('Standard Deviation')
plt.title('Standard Deviation of Bands')
plt.show()

print(f"The band with maximum information is Band {max_info_band + 1}")  # Adding 1 to convert from 0-based to 1-based index

import numpy as np
from scipy.io import loadmat
import matplotlib.pyplot as plt

# Load PaviaU dataset from MATLAB file
PaviaU_data = loadmat('/content/PaviaU.mat')  # Update the path
keys = PaviaU_data.keys()

print(keys)
print(PaviaU_data)

import numpy as np
from scipy.ndimage import variance
from scipy.io import loadmat
import matplotlib.pyplot as plt

# Load PaviaU dataset from MATLAB file
PaviaU_data = loadmat('/content/PaviaU.mat')  # Update the path
PaviaU = PaviaU_data['paviaU']

# Extract band 91
band_91 = PaviaU[:, :, 29]

# Calculate the lacunarity using variance
lacunarity_value = variance(band_91)

print(f"Lacunarity for Band 91 is: {lacunarity_value}")

# Display the band for visualization
plt.imshow(band_91, cmap='gray')
plt.title('Band 91')
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.io import loadmat
from sklearn.preprocessing import StandardScaler

# Load PaviaU dataset from MATLAB file
PaviaU_data = loadmat('/content/PaviaU.mat')  # Update the path
PaviaU = PaviaU_data['paviaU']  # Adjust based on the structure of your .mat file

# Select band 91
band_number = 91
selected_band = PaviaU[:, :, band_number]

# Normalize the data
selected_band_normalized = StandardScaler().fit_transform(selected_band.reshape(-1, 1)).reshape(selected_band.shape)

# Set up Lacunarity Distribution Algorithm parameters
box_sizes = [2, 4, 8, 16, 32]

# Implement Gliding Box Lacunarity Distribution Algorithm
def gliding_box_lacunarity(data, box_sizes):
    lacunarity_values = []
    processed_images = []

    for size in box_sizes:
        lacunarity_map = np.zeros_like(data)
        processed_image = np.zeros_like(data)

        for i in range(data.shape[0] - size + 1):
            for j in range(data.shape[1] - size + 1):
                sub_img = data[i:i+size, j:j+size]
                unique_labels = np.unique(sub_img)
                if 0 in unique_labels:  # Exclude background label
                    unique_labels = unique_labels[1:]
                lacunarity_map[i, j] = np.var(unique_labels)/np.mean(unique_labels)
                processed_image[i, j] = np.mean(sub_img)  # Processed image: example using mean

        lacunarity_values.append(np.mean(lacunarity_map))
        processed_images.append(processed_image)

    return lacunarity_values, processed_images

# Apply the algorithm to the selected band
lacunarity_values, processed_images = gliding_box_lacunarity(selected_band_normalized, box_sizes)

# Display lacunarity values for each box size
for i, size in enumerate(box_sizes):
    print(f"Gliding Box Lacunarity for Band {band_number} with box size {size}: {lacunarity_values[i]}")

# Display the original band for reference
plt.figure(figsize=(12, 4))
plt.subplot(1, 3, 1)
plt.imshow(selected_band_normalized, cmap='gray')
plt.title(f'Original Band {band_number}')

# Display the processed images
# Display the processed images
for i, size in enumerate(box_sizes):
    plt.subplot(1, len(box_sizes) + 1, i+2)
    plt.imshow(processed_images[i], cmap='gray')
    plt.title(f'Processed Image (Box Size {size})')

plt.tight_layout()
plt.show()

# Display lacunarity values
plt.plot(box_sizes, lacunarity_values, marker='o')
plt.xlabel('Box Size')
plt.ylabel('Gliding Box Lacunarity')
plt.title(f'Gliding Box Lacunarity for Band {band_number}')
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.io import loadmat
from sklearn.preprocessing import StandardScaler

# Load PaviaU dataset from MATLAB file
PaviaU_data = loadmat('/content/PaviaU.mat')  # Update the path
PaviaU = PaviaU_data['paviaU']  # Adjust based on the structure of your .mat file

# Select band 91
band_number = 91
selected_band = PaviaU[:, :, band_number]

# Normalize the data
selected_band_normalized = StandardScaler().fit_transform(selected_band.reshape(-1, 1)).reshape(selected_band.shape)

# Set up Gliding Box Lacunarity Distribution Algorithm parameters
box_sizes = [2, 4, 8, 16, 32]

# Implement Gliding Box Lacunarity Distribution Algorithm
def gliding_box_lacunarity(data, box_sizes):
    lacunarity_values = []
    processed_images = []

    for size in box_sizes:
        lacunarity_map = np.zeros_like(data)
        processed_image = np.zeros_like(data)

        for i in range(data.shape[0] - size + 1):
            for j in range(data.shape[1] - size + 1):
                sub_img = data[i:i+size, j:j+size]
                unique_labels = np.unique(sub_img)
                if 0 in unique_labels:  # Exclude background label
                    unique_labels = unique_labels[1:]
                lacunarity_map[i, j] = np.var(unique_labels)  # Using variance for lacunarity
                processed_image[i, j] = np.mean(sub_img)  # Processed image: example using mean

        lacunarity_values.append(np.mean(lacunarity_map))
        processed_images.append(processed_image)

    return lacunarity_values, processed_images

# Apply the algorithm to the selected band
lacunarity_values, processed_images = gliding_box_lacunarity(selected_band_normalized, box_sizes)

# Display lacunarity values for each box size
for i, size in enumerate(box_sizes):
    print(f"Gliding Box Lacunarity for Band {band_number} with box size {size}: {lacunarity_values[i]}")

# Display the original band for reference
plt.figure(figsize=(12, 4))
plt.subplot(1, 3, 1)
plt.imshow(selected_band_normalized, cmap='gray')
plt.title(f'Original Band {band_number}')

# Display the processed images
for i, size in enumerate(box_sizes):
    plt.subplot(1, len(box_sizes) + 1, i+2)
    plt.imshow(processed_images[i], cmap='gray')
    plt.title(f'Processed Image (Box Size {size})')

plt.tight_layout()
plt.show()

# Display lacunarity values
plt.plot(box_sizes, lacunarity_values, marker='o')
plt.xlabel('Box Size')
plt.ylabel('Gliding Box Lacunarity')
plt.title(f'Gliding Box Lacunarity for Band {band_number}')
plt.show()

print(selected_band)

pip install numpy opencv-python

import numpy as np
import matplotlib.pyplot as plt
from scipy.io import loadmat

# Load PaviaU dataset from MATLAB file
PaviaU_data = loadmat('/content/PaviaU.mat')  # Update the path
PaviaU = PaviaU_data['paviaU']  # Adjust based on the structure of your .mat file

# Select band 91
band_number = 91
band_91= PaviaU[:, :, band_number]

# Define ROI parameters (top-left corner coordinates and dimensions)
x, y, roi_width, roi_height = 0, 0, 50, 50  # Adjust these values based on your requirements

# Extract the ROI using NumPy array slicing
roi = band_91[y:y+roi_height, x:x+roi_width]

# Display the original Band 29 image and the extracted ROI
plt.figure(figsize=(10, 5))

plt.subplot(1, 2, 1)
plt.imshow(band_91, cmap='gray')
plt.title('Original Band 91')

plt.subplot(1, 2, 2)
plt.imshow(roi, cmap='gray')
plt.title('ROI (Upper-Left Corner)')

plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.io import loadmat

# Load PaviaU dataset from MATLAB file
PaviaU_data = loadmat('/content/PaviaU.mat')  # Update the path
PaviaU = PaviaU_data['paviaU']  # Adjust based on the structure of your .mat file

# Select band 91
band_number = 91
band_91 = PaviaU[:, :, band_number]

# Define ROI parameters (top-left corner coordinates and dimensions)
x, y, roi_width, roi_height = 275, 400, 50, 50  # Adjust these values based on your requirements

# Extract the ROI using NumPy array slicing
roi = band_91[y:y+roi_height, x:x+roi_width]

# Display the original Band 91 image and the extracted ROI
plt.figure(figsize=(10, 5))

plt.subplot(1, 2, 1)
plt.imshow(band_91, cmap='gray')
plt.title('Original Band 91')

plt.subplot(1, 2, 2)
plt.imshow(roi, cmap='gray')
plt.title('ROI (Bottom-Right Corner)')

plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.io import loadmat

# Load PaviaU dataset from MATLAB file
PaviaU_data = loadmat('/content/PaviaU.mat')  # Update the path
PaviaU = PaviaU_data['paviaU']  # Adjust based on the structure of your .mat file

# Select band 91
band_number = 91
band_91 = PaviaU[:, :, band_number]

# Get the dimensions of the dataset
height, width = band_91.shape

# Define ROI parameters for the upper-right corner
roi_width, roi_height = 50, 50  # Adjust these values based on your requirements
x = width - roi_width
y = 0

# Extract the ROI using NumPy array slicing
roi = band_91[y:y+roi_height, x:x+roi_width]

# Display the original Band 91 image and the extracted ROI
plt.figure(figsize=(10, 5))

plt.subplot(1, 2, 1)
plt.imshow(band_91, cmap='gray')
plt.title('Original Band 91')

plt.subplot(1, 2, 2)
plt.imshow(roi, cmap='gray')
plt.title('ROI (Upper-Right Corner)')

plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.io import loadmat

# Load PaviaU dataset from MATLAB file
PaviaU_data = loadmat('/content/PaviaU.mat')  # Update the path
PaviaU = PaviaU_data['paviaU']  # Adjust based on the structure of your .mat file

# Select band 91
band_number = 91
band_91 = PaviaU[:, :, band_number]

# Define ROI parameters (top-left corner coordinates and dimensions)
x, y, roi_width, roi_height = 20, 70, 50, 50  # Adjust these values based on your requirements

# Extract the ROI using NumPy array slicing
roi = band_91[y:y+roi_height, x:x+roi_width]

# Display the original Band 91 image and the extracted ROI
plt.figure(figsize=(10, 5))

plt.subplot(1, 2, 1)
plt.imshow(band_91, cmap='gray')
plt.title('Original Band 91')

plt.subplot(1, 2, 2)
plt.imshow(roi, cmap='gray')
plt.title('ROI (Randomly Selected)')

plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.io import loadmat

# Function to calculate gliding box lacunarity
def gliding_box_lacunarity(data, box_sizes):
    lacunarity_values = []
    processed_images = []

    for size in box_sizes:
        lacunarity_map = np.zeros_like(data)
        processed_image = np.zeros_like(data)

        for i in range(data.shape[0] - size + 1):
            for j in range(data.shape[1] - size + 1):
                sub_img = data[i:i+size, j:j+size]
                unique_labels = np.unique(sub_img)
                if 0 in unique_labels:  # Exclude background label
                    unique_labels = unique_labels[1:]
                lacunarity_map[i, j] = np.var(unique_labels)
                processed_image[i, j] = np.var(sub_img)  # Processed image: example using mean

        lacunarity_values.append(np.mean(lacunarity_map))
        processed_images.append(processed_image)

    return lacunarity_values, processed_images

# Load PaviaU dataset from MATLAB file
PaviaU_data = loadmat('/content/PaviaU.mat')  # Update the path
PaviaU = PaviaU_data['paviaU']  # Adjust based on the structure of your .mat file

# Select band 91
band_number = 91
band_91 = PaviaU[:, :, band_number]

# Get the dimensions of the dataset
height, width = band_91.shape

# Define ROI parameters for different corners
roi_params = [
    {"x": 0, "y": 0, "roi_width": 50, "roi_height": 50},  # Top-left corner
    {"x": 275, "y": 400, "roi_width": 50, "roi_height": 50},  # Bottom-right corner
    {"x": width - 50, "y": 0, "roi_width": 50, "roi_height": 50},  # Upper-right corner
    {"x": 20, "y": 70, "roi_width": 50, "roi_height": 50}
]

# Set up box sizes for lacunarity calculation
box_sizes = [2, 4, 8, 16, 32]

# Calculate lacunarity for each ROI
for idx, params in enumerate(roi_params):
    x, y, roi_width, roi_height = params["x"], params["y"], params["roi_width"], params["roi_height"]
    roi = band_91[y:y+roi_height, x:x+roi_width]

    # Apply gliding box lacunarity algorithm to the ROI
    lacunarity_values, processed_images = gliding_box_lacunarity(roi, box_sizes)

    # Display results for each ROI
    plt.figure(figsize=(12, 4))
    plt.subplot(1, len(box_sizes) + 1, 1)
    plt.imshow(roi, cmap='gray')
    plt.title(f'ROI {idx+1}')

    for i, size in enumerate(box_sizes):
        plt.subplot(1, len(box_sizes) + 1, i+2)
        plt.imshow(processed_images[i], cmap='gray')
        plt.title(f'Processed Image (Box Size {size})')

    plt.tight_layout()
    plt.show()

    # Display lacunarity values
    plt.plot(box_sizes, lacunarity_values, marker='o')
    plt.xlabel('Box Size')
    plt.ylabel('Gliding Box Lacunarity')
    plt.title(f'Lacunarity for ROI {idx+1}')
    plt.show()

    # Print lacunarity values
    print(f'Lacunarity values for ROI {idx+1}: {lacunarity_values}')

import matplotlib.pyplot as plt
import numpy as np
from scipy.io import loadmat

# Function to calculate gliding box lacunarity
def gliding_box_lacunarity(data, box_sizes):
    lacunarity_values = []
    processed_images = []

    for size in box_sizes:
        lacunarity_map = np.zeros_like(data)
        processed_image = np.zeros_like(data)

        for i in range(data.shape[0] - size + 1):
            for j in range(data.shape[1] - size + 1):
                sub_img = data[i:i+size, j:j+size]
                unique_labels = np.unique(sub_img)
                if 0 in unique_labels:  # Exclude background label
                    unique_labels = unique_labels[1:]
                lacunarity_map[i, j] = np.var(unique_labels)
                processed_image[i, j] = np.var(sub_img)  # Processed image: example using mean

        lacunarity_values.append(np.mean(lacunarity_map))
        processed_images.append(processed_image)

    return lacunarity_values, processed_images

# Load PaviaU dataset from MATLAB file
PaviaU_data = loadmat('/content/PaviaU.mat')  # Update the path
PaviaU = PaviaU_data['paviaU']  # Adjust based on the structure of your .mat file

# Select band 91
band_number = 91
band_91 = PaviaU[:, :, band_number]

# Get the dimensions of the dataset
height, width = band_91.shape

# Define ROI parameters for different corners
roi_params = [
    {"x": 0, "y": 0, "roi_width": 50, "roi_height": 50},  # Top-left corner
    {"x": 275, "y": 400, "roi_width": 50, "roi_height": 50},  # Bottom-right corner
    {"x": width - 50, "y": 0, "roi_width": 50, "roi_height": 50},  # Upper-right corner
    {"x": 20, "y": 70, "roi_width": 50, "roi_height": 50}
]

# Set up box sizes for lacunarity calculation
box_sizes = [2, 4, 8, 16, 32]

# Initialize lists to store lacunarity values for each ROI
all_lacunarity_values = []

# Calculate lacunarity for each ROI
for idx, params in enumerate(roi_params):
    x, y, roi_width, roi_height = params["x"], params["y"], params["roi_width"], params["roi_height"]
    roi = band_91[y:y+roi_height, x:x+roi_width]

    # Apply gliding box lacunarity algorithm to the ROI
    lacunarity_values, processed_images = gliding_box_lacunarity(roi, box_sizes)

    # Store lacunarity values for each ROI
    all_lacunarity_values.append(lacunarity_values)

# Plot all lacunarity values together
plt.figure(figsize=(12, 8))

for idx, lacunarity_values in enumerate(all_lacunarity_values):
    plt.plot(box_sizes, lacunarity_values, marker='o', label=f'ROI {idx+1}')

plt.xlabel('Box Size')
plt.ylabel('Gliding Box Lacunarity')
plt.title('Lacunarity for Different ROIs')
plt.legend()
plt.show()

